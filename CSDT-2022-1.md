# CSDT-2022-1
	  								     Yudy Camila Fuentes Pardo
											c√≥d 1000096896

## Contenido: üóÇÔ∏è 

* [Code smells](#Smells)
* [Refactoring](#Refactoring)
* [Clean code](#Cleancode)
* [Practicas XP](#Practicas)
* [Testing Debt](#TestingDebt)
* [An√°lisis de c√≥digo](https://github.com/CamiFuentes17/trivia/blob/master/CSDT_PrimeraEntrega2022.md)
* [Continous Integration](https://github.com/CamiFuentes17/trivia/blob/master/CSDT-CI.md)
* [Architectural Debt](#ArchitecturalDebt)
* [Metodolog√≠a ATAM + QAW](https://github.com/CamiFuentes17/trivia/blob/master/ATAM%2BQAW.md)



## Introducci√≥n: ‚ÑπÔ∏è 
Este proyecto consiste en una trivia, en la cual Nuestra trivia tiene mejoras que revisaremos a lo largo del proyecto debido a la falta de calidad y la deuda t√©cnica que esta presenta, los principales motivos para revisar esto es:

+ No tiene explicaciones del juego
+ Comentarios de funcionalidades
+ Encabezados
+ Documentaci√≥n

<a name="Smells"></a>
## Code Smells: ‚öôÔ∏è 

Para este caso se evidencia c√≥digo encontrado en la trivia a trabajar:
- Dispensables
- Duplicate Code la duplicidad existe por lo cual hace que este
- Clases dispensables sin esta clase el juego no funciona
- Acopladores 
- C√≥digo acoplado en √∫nica clase

<a name="Refactoring"></a>
## Refactoring: üìò

Evidenciando el c√≥digo fuente se puede hacer refactoring ya que:

	1. Existe duplicidad.
	2. No s√© est√° usando cierto c√≥digo.
	3. Hay repeticiones como se crean funciones y no se utilizan.
	
	Como se muestran en los siguientes ejemplos: 
	
```php
		for ($i = 0; $i < 50; $i++) {
					array_push($this->popQuestions, "Pop Question " . $i);
					array_push($this->scienceQuestions, ("Science Question " . $i));
					array_push($this->sportsQuestions, ("Sports Question " . $i));
					array_push($this->rockQuestions, $this->createRockQuestion($i));
		}
		}

		function createRockQuestion($index){
			return "Rock Question " . $index;
		}		
```			

```php
		echoln("They are player number " . count($this->players));
		return true;
		}

		function howManyPlayers() {
			return count($this->players);
		}
```
<a name="Cleancode"></a>
## Clean code: üèÉ‚Äç
	1. El c√≥digo no cumple con ser clean code porque no es entendible
	2. No es testeable o no tiene pruebas unitarias, si estas se realizan pierda su funcionalidad
	3. El c√≥digo no es enfocado debido a que delega muchas responsabilidades a muy pocos metodos

### YAGNI:
La trivia esta generando c√≥digo innecesario como se estaba mencionando debido a que no genera funcionalidad o no aporta o no es necesaria ejemplo:
		
```php
		function echoln($string) {
 		 echo $string."\n";
		}	
		
		echoln("They are player number " . count($this->players));
		return true;
		}

		function howManyPlayers() {
			return count($this->players);}
```

### KISS:
El c√≥digo puede ser simplificado y por el c√≥digo que esta implementado puede mejorar la calidad y ser m√°s entendible ejemplo:


```php
	function currentCategory() {
		if ($this->places[$this->currentPlayer] == 0) return "Pop";
		if ($this->places[$this->currentPlayer] == 4) return "Pop";
		if ($this->places[$this->currentPlayer] == 8) return "Pop";
		if ($this->places[$this->currentPlayer] == 1) return "Science";
		if ($this->places[$this->currentPlayer] == 5) return "Science";
		if ($this->places[$this->currentPlayer] == 9) return "Science";
		if ($this->places[$this->currentPlayer] == 2) return "Sports";
		if ($this->places[$this->currentPlayer] == 6) return "Sports";
		if ($this->places[$this->currentPlayer] == 10) return "Sports";
		return "Rock";
	}
```  
<a name="Practicas"></a>
## Practicas XP ‚ùó

>Las practicas que considero pueden ser implementadas para esta mejora son: 
>
>-	**Planning Game**: Para poder analizar y elegir las mejoras a aquellas funcionalidades, que son mas faciles de mejorar y as√≠ abarcar desde lo m√°s peque√±o a lo m√°s grande del proyecto e ir optimizando.
>
>-	**Small Releases**: Para ir revisando y estos avances y continuar con los avances progresivamente.
> 
>- 	**Continous integration**s: Con esto revisar que las integraciones del c√≥digo y los cambios realizados en el proyecto no esten afectando el mismo, para saber si este esta funcional, adicional que >tanto me afecta esto con la version incial.
>
>-	**Refactoring**: Si mis integraciones son buenas o es necesaria la refactorizacion. 
>
>-	**Coding standar**: Para as√≠ mantener la eficiencia y facilidad de entendimmiento en la trivia.
>
>-	**Whole Test**: Para dar finalidad y tener una prueba completa del producto finalizado.
	
<a name="TestingDebt"></a>
## Testing Debt üõ† 

En este caso en el proyecto no se evidencian pruebas unitarias, ni de integraci√≥n, no existen ni carpetas de test o evidencia que se pruebe en alg√∫n punto el juego.

De las implementaciones que se pueden realizar en estos casos son a los m√©todos como ejemplo:

+ Se deberia probar agregar jugadores para que estos agreguen de manera exitosa:
		Si realizamos testing a este m√©todo podemos comprobar cada vez que se agregue un usuario que este m√©todo funcione de manera correcta y se podr√≠a realizar como prueba unitaria.
		
```php
			function add($playerName) {
	   		array_push($this->players, $playerName);
	   		$this->places[$this->howManyPlayers()] = 0;
	   		$this->purses[$this->howManyPlayers()] = 0;
	   		$this->inPenaltyBox[$this->howManyPlayers()] = false;

	    		echoln($playerName . " was added");
	    		echoln("They are player number " . count($this->players));
			return true;
	}
```
+ En en este caso podr√≠amos despu√©s de realizar el clean code probar que cada uno de las casu√≠sticas se realicen correctamente, tanto como la condici√≥n como su retorno. 
```php
	function currentCategory() {
		if ($this->places[$this->currentPlayer] == 0) return "Pop";
		if ($this->places[$this->currentPlayer] == 4) return "Pop";
		if ($this->places[$this->currentPlayer] == 8) return "Pop";
		if ($this->places[$this->currentPlayer] == 1) return "Science";
		if ($this->places[$this->currentPlayer] == 5) return "Science";
		if ($this->places[$this->currentPlayer] == 9) return "Science";
		if ($this->places[$this->currentPlayer] == 2) return "Sports";
		if ($this->places[$this->currentPlayer] == 6) return "Sports";
		if ($this->places[$this->currentPlayer] == 10) return "Sports";
		return "Rock";
	}
```
+ Se podr√≠a realizar unit test al m√©todo de respuesta incorrectas para saber que este este funcional y vaya a ejecutarse de manera adecuada.
```php
	function wrongAnswer(){
		echoln("Question was incorrectly answered");
		echoln($this->players[$this->currentPlayer] . " was sent to the penalty box");
	$this->inPenaltyBox[$this->currentPlayer] = true;
```
	


Por lo cual se propone:

Viendo lo anterior podemos concluir que a los m√©todos que hemos indicado o en general en el proyecto implementando testing podemos reducir la deuda ya que podr√≠as implementar mejoras y realizar clean code, definiendo todos los ajustes y oportunidades que nos brinda el realizar el testing podemos concluir que se nos presentan las siguienten ventajas:

### Ventajas:

- **Aprendizaje continuo**: Considero que es una de las ventajas m√°s importantes ya que nos permite estar aprendiendo tanto en el momento de estar realizando el c√≥digo como en el momento de implementar las pruebas, podemos aprender de mejoras en los m√©todos o hacer un poco tanto de limpieza como de implementaciones. 
- **Calidad de c√≥digo**: Podemos ver como mejora nuestro c√≥digo al momento de probrarlo, se revisan diferentes escenarios y como se indica en el aprendizaje continuo podemos realizar diferente l√≥gica. 
- **Feedback Oportuno**: Nos permite estar en constante aprendizaje con el equipo implementando diferentes pruebas, diferentes escenarios los cuales puedo o pueden aplicar, en los cuales puedo o pueden aportar, es por esto que se ve crecimiento en el equipo.
- **Productividad**: Se vuelve m√°s productivo mi c√≥digo y eficiente al momento de realizar cualquier proceso, adicional la manera en la que se trabaja ya que al momento de realizar otros procesos se realizan de una manera m√°s limpia. 
- **Profesionalismo**: Tal como se menciona un poco en productividad nos vuelve mejores profesionales porque al realizar mejoras en la productividad y ser m√°s eficientes podemos ver como mejoramos nuestras implementaciones, l√≥gica y en todo lo que realizamos. 
- **Mejora Continua**: Realizar estos procesos nos permite interactuar con todas las caracter√≠sticas anteriores, por lo cual nos permite estar en un crecimiento continuo y estar mejorando tanto en nuestras habilidades. 


<a name="ArchitecturalDebt"></a>

## Architectural Debt: üèóÔ∏è

Para esta parte de proyecto vamos a analizar la deuda que se tiene a nivel de arquitectura, esta debido a las mejoras que se pueden realizar a la estructuras de nuestros proyectos con esto analizar y mejorar el sistema. 

Seg√∫n las deudas de arquitectura que se pueden tener en los proyectos y al ser este proyecto una peque√±a trivia se encontrar√≥n las siguientes deudas. 

>- **Package Hierarchies Unbalanced :**
>
>	<p> este es uno de los m√°s importantes para este caso ya que se ve afectada las jerarquias al no tener sino s√≥lo tiene dos clases y una esta cargada de toda la informaci√≥n y la otra √∫nicamente ejecuta esos procesos.</p>
>
>-  **No Layers :** 
>
>	No tiene capas por lo cual no se orienta de manera correcta como continuar con el proyecto, tanto en su documentaci√≥n como en los casos de que no se tiene divisiones de ning√∫n tipo ejm MVC (c√≥digo, negocio, datos, presentaci√≥n) esto hace que se cree una gran deuda t√©cnica. 
>>>		Ejemplo de MVC: 
>>>	
>>>		Donde se evidencia los procesos de cada una de las etapas que se deben a tener en cuenta.
>>>	
>>>	![image](https://user-images.githubusercontent.com/26396833/161463355-1c748896-fdf3-4efb-a5af-d246d52eb028.png)
>>>	
>>>		Proyecto actual: 
>>>	
>>>		Ac√° se evidencia la ausencia de las capas, por lo cual no contamos con el mismo.
>>>	
>>>	![image](https://user-images.githubusercontent.com/26396833/161463567-7b4eae7e-2c84-4abc-8caf-a67c68965569.png)
>
>- **Reinvent the Wheel :** 
>
>	Esto hace referencia a la obsolescencia del c√≥digo que no permite el mantenimiento, actualizaci√≥n, e innovaci√≥n del c√≥digo y su desarrollo, afectando a su arquitectura y haciendo que este no sea estable y se corra un riesgo. 
>
>- **Overgeneralization :** 
>
>	En este caso no se podr√≠a reutilizar el c√≥digo que se tiene, no existen maneras flexibles de adecuarlos para su mejora y no se puede utilizar y perfeccionar, esto afecta debido a que puede aumentar los costos y tiempos en los momentos que sean necesarias las mejoras en el proyecto.
>	
>- **Architecture by Implication :**	
>  
>	Este tipo ocurre cuando cuando se asume que la arquitectura esta bien por el √©xito de los proyectos o ya que no se ven tan implicados o necesarios, al tener esa confianza no se le da prioridad a la arquitectura y se pueden ver todos los da√±os anteriormente mencionados.
>	



### Autor  üë©‚Äçüéì üë©‚Äçüíª
  Yudy Camila Fuentes Pardo
